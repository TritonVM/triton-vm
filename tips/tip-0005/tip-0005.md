# TIP 0005: Hash Function

| TIP            | 0005                                                                            |
|:---------------|:--------------------------------------------------------------------------------|
| authors:       | Alan Szepieniec and Alexander Lemmens and Ferdinand Sauer and Bobbin Threadbare |
| title:         | Tip5 Hash Function                                                              |
| status:        | request for comments                                                            |
| created:       | 2022-11-17                                                                      |
| issue tracker: | [161](https://github.com/TritonVM/triton-vm/pull/161)                           |
| pdf:           | [pdf](tip5-paper.pdf)                                                           |

**Abstract.**
This note proposes a new arithmetization-oriented hash function. It uses the SHARK design strategy [1] in combination with lookup tables, and is defined over the field with $p=2^{64}-2^{32}+1$ elements. This note also discusses techniques for efficiently arithmetizing the hash function.

## Introduction

In the space of arithmetization-oriented hash function, two design strategies stand out.

 1. The Marvellous design strategy [2], best known for its member Rescue-Prime [3], introduced the idea of alternating S-box layers where even layers compute low-degree permutations in one direction and odd layers compute low-degree permutations in the opposite direction. As a result, a small number of rounds guarantees that the algebraic degree of the cipher is sufficiently high when attacked from any direction. Moreover, in the specific case of Rescue-Prime, two consecutive S-box layers can be folded together into one low-degree arithmetization. This folding technique yields essentially two rounds of the cipher for the price of one cycle in the arithmetic virtual machine. Since the publication of the Marvellous design strategy, there has been very little progress in cryptanalyzing Rescue and Rescue-Prime.

 2. Reinforced Concrete [4] introduced the use of lookup tables in an otherwise arithmetization-oriented cipher. The lookup table can be evaluated efficiently on CPUs as well as proven efficiently in a zero-knowledge or succinctly verifiable proof system using Plookup [5] or techniques derived from there. Moreover, represented as polynomials over a finite field, non-trivial lookup tables have maximal degree. Therefore, the use of lookup tables provides a robust way to resist algebraic attacks including attacks relying on Gröbner bases. The downside of this technique is that the lookup tables cannot be too large; that therefore the field elements must be decomposed into chunks which are then looked up; and that the prover must establish the correct decomposition and recomposition of these chunks. This process leads to an expensive arithmetization and does not generalize well to arbitrary fields.

This note proposes a new hash function. It uses the SHARK design strategy, on which Marvellous is based, of using full S-box layers interleaved with MDS matrices. The S-boxes come in two types. The first is built from a table lookup that computes the cube map in $\mathbb{F}_{2^{8}+1}$ but offset by one. In addition to being fast to compute, this function makes the algebraic degree large and provides resistance against Gröbner basis attacks. The second type is the regular forward $\alpha$ th power map found in Rescue and Poseidon. As the second type of S-boxes constitutes the majority in every S-box layer, they suffice to provide defense against statistical attacks through the wide-trail argument.

This note also includes an arithmetization of the hash function in the STARK context. This arithmetization includes a novel lookup argument, which can be seen as lifting that of Haböck [7] to the appropriate context.

*Acknowledgements.* Many of the ideas used in this note came were first discussed in the course of the Rescue-Prime Optimization project [6].

## Specification

### Basic Parameters

| Parameter                             | Symbol   |                 Value |
|:--------------------------------------|:---------|----------------------:|
| field modulus                         | $p$      | $2^{64} - 2^{32} + 1$ |
| number of rounds                      | $N$      |                     5 |
| state size                            | $m$      |                    16 |
| sponge rate                           | $r$      |                    10 |
| sponge capacity                       | $c$      |                     6 |
| digest length                         | $d$      |                     5 |
| power map exponent                    | $\alpha$ |                     7 |
| number of split-and-lookups per round | $s$      |                     4 |

For the sake of genericity the rest of the note uses the symbol rather than the value.

### S-Box

There are two types of S-boxes. One is the regular forward $\alpha$-th power map already used in Rescue-Prime. Denote this map by $T : x \mapsto x^\alpha$. For the field with $2^{64} - 2^{32} + 1$ elements, $\alpha = 7$.

The other type is more involved and may be called the split-and-lookup map. Every round consists of one S-box layer; in this layer the first $s$ state elements are mapped by the split-and-lookup map and the second $m-s$ state elements are mapped by the forward $\alpha$-th power map.

The split-and-lookup map is defined as follows:

$$ S : \mathbb{F}_p \rightarrow \mathbb{F}_p,  x \mapsto R^{-1} \cdot \rho \circ L^8 \circ \sigma  (R \cdot x) $$

The components are:

 - $R$ is the field element congruent to $2^{64}$ modulo $p$, accounting for native representation of field elements in Montgomery form.
 - $\sigma : \mathbb{F}_p \rightarrow \mathbb{F}_p^8, x \mapsto (a, b, c, d, e, f, g, h)$ where all outputs are at most 8 bits wide and $x = a + 2^{8} \cdot b + 2^{16} \cdot c + 2^{24} \cdot d + 2^{32} \cdot e + 2^{40} \cdot f + 2^{48} \cdot g + 2^{56} \cdot h$.
 - $L : \mathbb{F}_ p \rightarrow \mathbb{F}_ p$ is defined only for field elements that are at most 8 bits wide. Identifying this subset of $\mathbb{F}_ p$ with $\mathbb{F}_ {2^{8}+1}$, the lookup table $L$ computes $L : \mathbb{F}_ {2^{8}+1} \rightarrow \mathbb{F}_ {2^{8}+1}, x \mapsto (x+1)^3-1$.
 - $\rho : \mathbb{F}_ p^8 \rightarrow \mathbb{F}_ p$ computes the inverse of $\sigma$.

The inverse of this S-box is $x \mapsto R \cdot \rho \circ (L^{-1})^4 \circ \sigma (R^{-1} \cdot x)$.

One input-output pair is noteworthy $S(-1) = -1$.

### Remaining Specifications

A single round consists of three steps:

 1. A full S-box layer, in which the first $s$ elements are mapped by $S$ and the next $m-s$ elements by $T$.
 2. Matrix-vector multiplication of the MDS matrix with the state (as the column vector). The MDS matrix is circulant, giving rise to fast matrix-vector products. When $m=16$, the MDS matrix is the one given by the first column: `[61402, 1108, 28750, 33823, 7454, 43244, 53865, 12034,
56951, 27521, 41351, 40901, 12021, 59689, 26798, 17845].` The byte format representation of this vector corresponds to the SHA-256 hash of the ASCII string "`Tip5`"
 3. Addition of constants. A preselected random constant is added into every element of the state.

The constants are determined by concatenating the byte $i$ (for the $i$ th constant, starting from zero) to the ASCII string "`Tip5`", hashing the string of 5 bytes using Blake3, taking the first 16 bytes of the digest, interpreting them as an integer in least-significant-byte-first order, reducing the integer modulo $p$, and multiplying the resulting field element by $R^{-1}$ which is the inverse of $2^{64}$ modulo $p$. This process is repeated $mN$ times to get as many round constants. The $(mi + j)$ th constant is used for the $j$ th state element in the $i$ th round.

The permutation $P$ consists of $N$ rounds. The hash function is obtained by instantiating the sponge construction with the permutation $P$ and truncating the output to length $d$.

The hash function comes in two modes of operation, depending on whether the input is fixed-length or variable-length.

 - When the input is fixed length (and in this case the length is always exactly $r = 10$), all capacity elements are initialized to 1. There is no need to pad the input. There is only one absorption.
 - When the input is variable-length, it is padded by appending a 1 followed by however many 0's as are necessary to make the padded input length a multiple of $r$. The capacity is initialized to all zeros and the input is absorbed over multiple iterations.

## Implementation Aspects

### Montgomery Representation

A field element $a \in \mathbb{F}_p$ is represented as the integer $\bar{a} \in \{0, \ldots, p-1\}$ congruent to $a \cdot R$ modulo $p$, where $R = 2^{64}$. The benefit of this representation is a faster multiplication algorithm: the product $c = ab$ is calculated by first calculating the integer product $\bar{a} \cdot \bar{b}$ and following this up with *Montgomery reduction*, which sends $\bar{a} \cdot \bar{b}$ to $\bar{c}$. We refer to Pornin's explanation [8] for a concise but comprehensive overview of Montgomery representation of elements in this field.

The split-and-lookup S-box anticipates the use of Montgomery representation. Specifically, the S-box 

$$ S : \mathbb{F}_p \rightarrow \mathbb{F}_p,  x \mapsto R^{-1} \cdot \rho \circ L^8 \circ \sigma  (R \cdot x) $$

becomes 

$$ S' : \mathbb{F}_p \rightarrow \mathbb{F}_p,  x \mapsto \rho' \circ L^8 \circ \sigma'  (x) $$

where $\sigma'$ decomposes the integer $\bar{a}$ into raw bytes, and $\rho'$ recomposes the raw bytes accordingly.

### MDS Matrix Multiplication

In the linear step, the state vector $\mathbf{x}$ is sent to $M \mathbf{x}$ where $M$ is the circulant MDS matrix. All the entries in this matrix are small positive integers. The purpose of this design choice is to delay modular reduction. Specifically, the matrix-vector multiplication is computed over the integers twice, once for the high 32 bits of the input vector, and once for the low 32 bits. Afterwards, the two output vectors are added over the integers (with the appropriate shift) before being reduced modulo $p$.

Another salient property of the MDS matrix is the fact that it is circulant. Using the well-known NTT-based multiplication trick, the matrix-vector product for a circulant matrix can be computed in only $O(m \log m)$ operations via
$$ M \mathbf{x} = \mathsf{NTT}^{-1} (\mathsf{NTT}(M_{[:,0]}) \circ \mathsf{NTT}(\mathbf{x})) , $$
where $\circ$ denotes the Hadamard (element-wise) product.

The reason why the NTT-based multiplication trick works is because there is an isomorphism between circulant matrices and elements of the quotient ring $R_p = \mathbb{F}_p[X] / \langle X^m - 1 \rangle$. The elements of this ring are uniquely determined by their reduced representative modulo $X^m-1$, or by their list of reduced representative modulo any list of polynomials whose product is $X^m-1$. The irreducible factors of $X^m-1$ are $X - \xi^i$, where $\xi$ is a primitive $m$th root of unity; and by reducing a polynomial modulo these factors we get its evaluation in $\xi^i$. The is precisely NTT is the transformation that sends a polynomial, represented as a list of coefficients, to its list of evaluations in $\xi^i$.

However, while the field $\mathbb{F}_p$ does have an $m$th root of unity, the ring of integers does not. To deal with this difficulty, we use an alternative factorization of $X^m-1$. In the first step we split the polynomial product modulo $X^m-1$ into two polynomial products, modulo $X^{m/2} - 1$ and $X^{m/2} + 1$ respectively. The first product can be computed recursively. The second product is split again into polynomial products modulo $X^{m/4} + \xi^4$ and $X^{m/4} - \xi^4$ respectively, where $\xi^4$ is a square root of $-1$. The coefficients are represented as complex numbers, \emph{i.e.}, with a real part and an imaginary part. As a result of this representation, computing the product modulo $X^{m/4} + \xi^4$ gives the matching result modulo $X^{m/4} - \xi^4$ for free through complex conjugation. The polynomial product before reduction is computed with [Karatsuba's method](https://en.wikipedia.org/wiki/Karatsuba_algorithm).

## Lookup Argument

The lookup argument  establishes that the values appearing on the trace non-deterministically were in fact integrally looked up. It consists of two independent components. First is an argument for proving that two given vectors satisfy a subset relation (as sets). This primitive is presented in two steps: the intuition and security is articulated in terms of a Bézout relation, whereas the concrete construction works in terms of logarithmic derivatives. This subset argument is used in several places in the second component, which is the cascade construction. Its purpose is to break down large lookup tables into smaller ones, benefiting the overall arithmetic complexity. After describing these components we put everything together for a concrete arithmetization of Tip5, lookup gates an all.

### Bézout Argument

The subset argument is a cross-table argument between two tables, which for the sake of genericity are called the *server* and the *client*. The The client table contains a list of input-output pairs with repetitions and in an arbitrary order. The server table lists *all possible* input-output pairs. The argument establishes that as sets, the client's input-output pairs are a subset of those of the server.

Using random weights from the verifier `a, b`, the input and output columns are compressed into one random linear combination. It then suffices to show that the set of random linear combinations of the client, is a subset of the random linear combinations of the server.

Let $\lbrace \texttt{rlc}_i \rbrace_i$ denote the set of input-output pairs, each compressed into a random linear combination sing `a` and `b`, that are looked up at least once. The client and server tables both define a product polynomial whose factors are random linear combinations offset by $X$.

$$ \texttt{rpc}(X) = \prod_i (\texttt{rlc}_i - X)^{m_i} $$

$$ \texttt{rps}(X) = \prod_i (\texttt{rlc}_i - X) $$

The difference between these two polynomials is the multiplicities $m_i$ of their roots, which is 1 for the Lookup Table and possible greater than 1 for the Hash Table. The letter `r` suggests that these values of these polynomials in $\alpha$ can be computed by *running product* columns, once $\alpha$ is known. But merely comparing the values $\texttt{rpc}(\alpha)$ and $\texttt{rps}(\alpha)$ does not suffice – the multiplicities of the roots are different.

The following Bézout relation argument eliminates these multiplicities, enabling a test for subset relationship by probing a polynomial identity in the random point $\alpha$.

In addition to a *running product*, the client table defines a *formal derivative*. Let $\texttt{fdc}(X)$ denote this polynomial:

$$ \texttt{fdc}(X) = \sum_i m_i (X - \texttt{rlc}_i)^{m_i - 1} \prod_{j \neq i} (X - \texttt{rlc}_j)^{m_j} = \frac{d}{dX} \texttt{rpc}(X) $$

Likewise, the server table defines a formal derivative as well, except this one is weighted by multiplicity:

$$ \texttt{mwfds}(X) = \sum_i m_i \prod_{j \neq i} (X - \texttt{rlc}_j) $$

On the side of the client, the running product and its formal derivative satisfy the following Bézout relation: $\texttt{rpc}(X) \cdot x(X) + \texttt{fdc}(X) \cdot y(X) = g(X)$, where $g(X)$ is the greatest common divisor and $x(X)$ and $y(X)$ are Bézout coefficient polynomials. Then $\frac{\texttt{rpc}(X)}{g(X)}$ is the square-free polynomial with the same roots as $\texttt{rpc}(X)$, and equal to $\texttt{rps}(X)$ of the server. Moreover, a similar relationship holds for the formal derivatives: $\frac{\texttt{fdc}(X)}{g(X)} = \texttt{mwfds}(X)$. By eliminating $g(X)$ we get the identity of polynomials $\texttt{rpc}(X) \cdot \texttt{mwfds}(X) = \texttt{fdc}(X) \cdot \texttt{rps}(X)$. The objective is to test this identity in the random point $\alpha$.

The cheating prover who uses an input-output pair not present in the server table must use a polynomial $\texttt{rpc}(X)$ with at least one root that $\texttt{rps}(X)$ does not share. As a result, the polynomial identity is not satisfied because this root occurs in the left hand side with multiplicity one greater than in the right hand side. By the Schwarz-Zippel lemma, the probability that the identity holds in the random point $\alpha$ is at most $\frac{(1 + m/2) T}{|\mathbb{F}|}$, where $T$ is the padded height of the table.

### Optimization with Logarithmic Derivatives

The above intuition gives rise to an AET and AIR for checking it. Indeed, the values `rpc(α)`,`fdc(α)`, `rps(α)`, and `mwfds(α)` can all be computed via running accumulator columns. However, it turns out there is an optimization that reduces the number of columns at the expense of a batch-inversion. This optimization is inspired by Haböck's lookup argument [7] but ultimately that argument is tailored to Multilinear IOPs. The present optimization can be seen as lifting that technique to the AET/AIR setting, albeit derived differently.

The logarithmic derivative of a polynomial $f(X)$ is defined as $\frac{f'(X)}{f(X)}$. The logarithmic derivative is so named because the logarithmic derivative of the product of two polynomials is the sum of their logarithmic derivatives: $\frac{\mathsf{d}(f(X)g(X))}{f(X)g(X)\mathsf{d}X} = \frac{f'(X)g(X)}{f(X)g(X)} + \frac{f(X)g'(X)}{f(X)g(X)} = \frac{f'(X)}{f(X)} + \frac{g'(X)}{g(X)}$.

Observe that the polynomial identity

$$ \texttt{rph}(X) \cdot \texttt{mwfdl}(X) = \texttt{fdh}(X) \cdot \texttt{rpl}(X) $$

can be re-written in terms of logarithmic derivatives:

$$ \frac{\texttt{fdc}(X)}{\texttt{rpc}(X)} = \frac{\texttt{mwfds}(X)}{\texttt{rps}(X)} = \sum_i \frac{m_i}{X - \texttt{rlc}_i} .$$

On the side of the server, two columns are needed to probe this identity in the random point $\alpha$.

 - the running product `rps` and multiplicity-weighted formal derivative `mwfds` are merged into the single extension column `sum`, which contains the running sum of `mul / (α - rlc)`;
 - base column `mul` contains the multiplicity with which the given row is queried.

On the client only *one* extension column is needed. Specifically, the running product `rpc` and formal derivative `fdc` are merged into a single column, the logarithmic derivative `ldc`.

To update `ldc`, recall that the standard running product column `rpc` is defined to accumulate one *factor* in every row. Moreover, `ldc` is defined to contain the logarithmic derivative of `rpc` in every row, so we can use the eponymous property to populate it. Specifically, the would-have-been running product update rule `rpc* = rpc ⋅ (α - rlc*)` becomes `ldc* = ldc + 1/(α - rlc*)`, where the asterisk `*` indicates the respective element from the next row.

The update rules `sum* = sum + mul* / (α - rlc*)` and `ldc* = ldc + 1 / (α - rlc*)` can be converted to AIR constraints by multiplying left and right hand sides by `(α - rlc*)`.

### Cascade Construction

The cascade construction arithmetizes a composite lookup gate in terms of multiple lookups into component gates followed by combining the looked-up outputs. For example, suppose that a 16-bit wide map can be represented as the concatenation of two 8-bit wide lookups. Then this 16-bit wide map can be arithmetized with a cascade table as follows. The cascade table is the *server* authenticating 16-bit wide input-output pairs to the external client. Internally, every input or output element is represented as two limbs of 8 bits. To authenticate the 8-bit wide input-output pairs, the cascade table is the *client* of an 8-bit wide subset argument with an external server.

A cascade table consists of 5 base columns and 3 extension column. The extension columns are defined relative to challenges `a,b,c,d,β,γ`. The Latin letters denote weights used to compress columns, and the Greek letters denote indeterminates.

The base columns are

 - `lkinhi` and `lkinlo`, the high and low limbs of the lookup input;
 - `lkouthi` and `lkoutlo`, the high and low limbs of the lookup output;
 - `mul`, the multiplicity with which the given row is being queried by the external client.

The extension columns are

 - `sum`, which contains the running sum of inverses;
 - `ldhi` and `ldlo`, the running logarithmic derivatives of the high and low input-output pairs.

The AIR constraints can be inferred from the section about the Bezout relation argument and its optimization in terms of logarithmic derivatives. Note that when the cascade table is wearing the server hat, the random linear combinations are given by

$$ \mathtt{rlc} = 2^{w} \cdot a \cdot \mathtt{lkinhi} + a \cdot \mathtt{lkinlo} + 2^{w} \cdot b \cdot \mathtt{lkouthi} + b \cdot \mathtt{lkoutlo} , $$

where $w$ is the width (in bits) of each limb. When the cascade table is wearing the client hat, the random linear combinations are given by

$$ \mathtt{rlc} = c \cdot \mathtt{lkinhi} + d \cdot \mathtt{lkouthi} $$

and

$$ \mathtt{rlc} = c \cdot \mathtt{lkinlo} + d \cdot \mathtt{lkoutlo}. $$

To see why the construction is sound, suppose a malicious prover attempts to prove that a pair $(\mathtt{lkin}^*, \mathtt{lkout}^*)$ belongs to the wide lookup relations when it does not. Then either the cascade table contains a corresponding row $(\mathtt{lkinhi}^*, \mathtt{lkinlo}^*, \mathtt{lkouthi}^*, \mathtt{lkoutlo}^*, \mathtt{mul})$, *i.e.*, such that $\mathtt{lkin}^* = 2^w \cdot \mathtt{lkinhi}^* + \mathtt{lkinlo}$ and $\mathtt{lkout}^* = 2^w \cdot \mathtt{lkouthi}^* + \mathtt{lkoutlo}$ and $\mathtt{mul} \neq 0$; or the cascade table does not contain such a corresponding row. The latter case implies a failure of the client-cascade subset argument. The probability of this event is bounded by the soundness error of the subset argument. The former case implies one of two propositions:

 1. The server table for the narrow lookup contains a row $(\mathtt{lkinhi}^*, \mathtt{lkouthi}^*, \mathtt{mul})$ with $\mathtt{mul} \neq 0$.
 2. The server table for the narrow lookup contains a row $(\mathtt{lkinlo}^*, \mathtt{lkoutlo}^*, \mathtt{mul})$ with $\mathtt{mul} \neq 0$.

The propositions cannot both be true because that would imply that $(\mathtt{lkin}^*, \mathtt{lkout}^*)$ does satisfy the relation defined by the wide lookup. Therefore, one or both of these propositions must be false, implying at least one violation of the cascade-server subset argument. Once again, the probability of this event is bounded by the soundness error of the subset argument.

It is possible to arrange multiple cascade tables in a, well, *cascade*. This enables the decomposition of very large composite lookup maps into tiny components. The tradeoff is that the number of rows can increase by up to a factor two for every cascade level. However, as the tables get narrower they start becoming saturated faster. For instance, an 8-bit wide lookup table can only hold 256 rows.

## Arithmetization of Tip5 Hash Function

After committing to the base column, the prover obtains random challenges from the verifier (or from Fiat-Shamir). The challenges used here are $a, b, c, d, \beta, \gamma, \delta$.

There are three tables in total: the hash table, the 16-bit wide cascade table, and the 8-bit wide lookup table. The hash table looks up $s \times 4$ input-output pairs of 16 bits in the cascade table, and the cascade table looks up the low and high limbs in the 8-bit wide lookup table. The relations between the hash table and other tables, as well as the columns and constraints that effect them, are out of scope for this note.

### Hash Table

Since $N = 5$ is not one less than a power of two, complicating arithmetic somewhat. By using 8 rows for every hash invocation, we can leverage periodic zerofiers. As a result, consistency or transition constraints can be activated or deactivated on rows congruent to $j$ mod 8, for any $j$.

A regular zerofier is the lowest-degree monic polynomial that sends a subgroup $H$ to zero. When this subgroup $H \subset \mathbb{F}^*$ has order $N$, this polynomial is given by $Z_H(X) = X^N - 1$. Let $\omega$ be a primitive 8th root of unity. The periodic zerofier $Z(X) = X^{N/8}-1$ maps every 8th element of $H$ to zero starting at $1 = \omega^0$ and $Z_H(\omega^{-i} \cdot X)$ does the same but starting at $\omega^i$.

Every lookup-input and every lookup-output must be explicitly represented. So $s$ field elements being mapped by the split-and-lookup S-box turn into $4 \cdot 2 \cdot s$ columns. Let `lkin[i]` and `lkout[i]` with `i in {0, ..., 4s-1}` denote these columns. For each pair `(lkin[i], lkout[i])` there is 1 extension column, `ldh[i]`, which accumulates a logarithmic derivative update.

The columns are as follows:

 - `pad` indicates whether the row is a padding row or not.
 - `lkin[4⋅i+j]`, `lkout[4⋅i+j]`, and `ldh[4⋅i+j]` for `j in [0,1,2,3]` and `i in [0,1,2,3]` for the `4` = $s$ state elements that are being split (into 8 pieces each) and looked up.
 - `st[i]` for `i in [4,5,6,7,8,9,10,11,12,13,14,15]` for the 12 remaining state elements that are mapped by the forward alpha power map.
 - `lkininv[i]` for `i in [0,1,2,3]` which contains the inverse-or-zero needed to establish the unique decomposition of the field element into 16-bit chunks.

 The rest of this arithmetization makes reference to `const[i]` for `i in [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]` for the round constants. These can be conceived of as columns but in practice it is more efficient to implement them via periodic interpolants.

The total number of columns is therefore 61. Of these 61 columns, 45 are base columns and 16 are extension columns.

*Initial constraints.*

 1. The very first logarithmic differential starts off having accumulated the first update: `ldh[0] ⋅ ( γ - a⋅lkin[0] - b⋅lkout[0] ) - 1`.

*Consistency constraints.* 

 1. The padding indicator is 0 or 1: `pad ⋅ (1 - pad)`.
 2. The round constants columns are populated correctly. Specifically, in rows congruent to $j$ mod 8, `const[i] - round_constants[j⋅m+i]` for `i in [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]`. Note that the round constants are only defined for `j in [0,1,2,3,4]`; in other rows the round constants are unconstrained.
 3. The logarithmic differential columns within each row accumulate the right update. Specifically,
  - `1 + ( γ - a⋅lkin[4⋅i+j+1] - b⋅lkout[4⋅i+j+1] ) ⋅ ( ldh[4⋅i+j] - ldh[4⋅i+j+1] )` for `j in [0,1,2,3]` and `i in [0,1,2]`.
  - `1 + ( γ - a⋅lkin[4⋅(i+1)] - b⋅lkout[4⋅(i+1)] ) ⋅ ( ldh[4⋅i+3] - ldh[4⋅(i+1)] )` for `i in [0,1,2]`.
 4. In padding rows, the state is zero:
  - `pad ⋅ lkin[4⋅i+j]` for `i in [0,1,2,3]` and `j in [0,1,2,3]`;
  - `pad ⋅ lkout[4⋅i+j]` for `i in [0,1,2,3]` and `j in [0,1,2,3]`;
  - `pad ⋅ st[i]` for `i in [4,5,6,7,8,9,10,11,12,13,14,15]`.
 5. The lookup-inputs represent valid field elements – specifically, if the high limbs are all ones, then the low limbs must be all zeros. `(1 - (lkin[4i]-65535) ⋅ (lkin[4i+1]-65535) ⋅ lkininv[i]) ⋅ (lkin[4i+2] + lkin[4i+3])` for `i in [0,1,2,3]`.

*Transition constraints.*

 1. In non-padding rows congruent to 0, 1, 2, 3, or 4 mod 8, the round function is applied. Specifically, 
  - let `s[i] = sum(lkout[4⋅i+j] ⋅ (256^j) for all j in [0,1,2,3])` for `i in [0,1,2,3]`;
  - let `t[i] = st[i+4]^7` for `i in [0,1,2,3,4,5,6,7,8,9,10,11]`;
  - let `subst = s[0] || s[1] || s[2] || s[3] || t[0] || t[1] || t[2] || t[3] || t[4] || t[5] || t[6] || t[7] || t[8] || t[9] || t[10] || t[11] || t[12]`;
  - let `st*[i] = sum(lkin*[4⋅i+j] for j in [0,1,2,3])` for `i in [0,1,2,3]`;
  - then `(1 - pad) ⋅ (sum(MDS[i][j] ⋅ subst[j] for all j) + const[i] - st*[i])` for `i in [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]`.
 2. In rows congruent to 5 or 6 mod 8, the state does not change. Specifically:
  - `lkin[4⋅i+j] - lkin*[4⋅i+j]` for all `i in [0,1,2,3]` and `j in [0,1,2,3]`
  - `lkout[4⋅i+j] - lkout*[4⋅i+j]` for all `i in [0,1,2,3]` and `j in [0,1,2,3]`
  - `st[i] - st*[i]` for all `i in [4,5,6,7,8,9,10,11,12,13,14,15]`.
 3. In rows congruent to 7 mod 8, the next state is unconstrained. (This does not give rise to any constraints.)
 4. The first logarithmic derivative of the next row updates the last logarithmic derivative from the current row and integrates the right update: `1 + ( γ - a⋅lkin*[0] - b⋅lkout*[0] ) ⋅ ( ldh[15] - ldh*[0] )`.

 *Terminal constraints.* None.

### Cascade Table

The cascade table has 5 base columns and 3 extension columns. They are:

 - `lkinhi`, `lkinlo` (base) are the high and low limbs of the input;
 - `lkouthi`, `lkoutlo` (base) are the high and low limbs of the output;
 - `mul` (base) is the multiplicity with which the current row is being queried;
 - `ldhi` and `ldlo` (extension) are the running logarithmic derivative columns for the high and low pairs, respectively;
 - `sum` (extension) is the running sum of inverses.

Additionally, column `pad` indicates whether a given row is a padding row.

*Initial constraints.*

 1. If the first row is not padding, the sum of inverses column starts off having accumulated the term associated with the first row; otherwise this sum is zero. `pad ⋅ (sum ⋅ (γ - a ⋅ lkinhi ⋅ 2^8 - a ⋅ lkinlo - b ⋅ lkouthi ⋅ 2^8 - b ⋅ lkoutlo) - mul) + (1-pad) ⋅ sum`.
 2. If the first row is not padding, the high limb logarithmic derivatives starts off having integrated the first update; otherwise it starts off set to zero.
   - `pad ⋅ (ldhi ⋅ (β - c ⋅ lkinhi - d ⋅ lkouthi) - 1) + (1-pad) ⋅ ldhi`

*Consistency constraints.*

 1. The padding indicator is a bit: `pad ⋅ (1 - pad)`.
 1. If the row is not padding, the low limb logarithmic derivative updates the high limb one; otherwise no update. `pad ⋅ ((ldhi - ldlo) ⋅ (β - c⋅lkinlo - d⋅lkoutlo) + 1) + (1-pad) ⋅ (ldhi - ldlo)`

*Transition constraints.* If the new row is not padding, the high limb logarithmic derivative updates the low limb one from the previous row; otherwise no update. `pad* ⋅ ((ldlo - ldhi*) ⋅ (β - c*lkinhi* - d*lkouthi*) + 1) + (1-pad*) ⋅ (ldlo - ldhi*)`

*Terminal constraints.* None.
  
### Lookup Table

To establish the correct contents of the Lookup Table, it suffices to compute one running evaluation in an extension column `re`. As there are only 256 elements of the table and as all are known to the verifier, the verifier can compute the terminal value of this running evaluation locally. This construction gives rise to one initial constraint, one transition constraint, and one terminal constraint.

More specifically, there are 6 columns:
 - base column `lkin` and `lkout` contain the input-output pairs;
 - base column `mul` contains the multiplicity with which it is being looked up;
 - base column `pad` indicates whether the row is padding or not;
 - extension column `re` contains the running evaluation for proving the correct input-output pairs;
 - extension column `sum` contains the running sum of inverses.

*Initial constraints.* 

 1. The running evaluation starts off having accumulated the first term: `re - δ + c⋅lkin + d⋅lkout`.
 2. The running sum of inverses starts off having accumulated the first row: `mul - (β - c⋅lin - d⋅lout) ⋅ sum`.

*Consistency constraints.*

 1. The padding indicator is a bit: `pad ⋅ (1 - pad)`.
 2. The input and output are set to zero in padding rows: `lkin ⋅ pad` and `lkout ⋅ pad`.
 3. The multiplicity is zero in padding rows: `mul ⋅ pad`.

*Transition constraints.*

 1. The running evaluation accumulates one term in every non-padding row, and remains in padding rows: `(β⋅re + a⋅lin* + b⋅lout* - re*) ⋅ (1 - pad) + (re - re*) ⋅ pad`.
 2. The running sum of inverses accumulates one update in every non-padding row, and remains in padding rows: `(pad - 1) ⋅ (mul* + (γ - a⋅lin* - b⋅lout*) ⋅ (sum - sum*)) + pad ⋅ (sum - sum*)`.

*Terminal constraints.*

 1. The `(lin,lout)` pairs are correct. To verify this, let $B = \sum_{i=0}^{255} (a \cdot i + b \cdot L(i)) \cdot \delta^{255-i}$ be computed locally by the verifier via the recursive Horner relation $B_0 = 0$ and $B_{n+1} = \delta \cdot B_n + a \cdot n + b \cdot L(n)$ such that $B_{255} = B$. Then the terminal constraint is `re - B`.

### Cross-Table Constraints

With the above columns and AIR constraints, the remaining piece of the entire cascading lookup argument is two cross-table constraints, both of which equate the logarithmic derivative to the running sum. Between the hash table and the cascade table this is `ldh[15] - sum`. Between the cascade table and the lookup table this is `ldlo - sum`.

### Summary

The next table gives an overview of the base and extension column used in the various tables.

| Table     | base | extension | sum | B-field equivalent sum |
|:----------|-----:|----------:|----:|-----------------------:|
| Hash      |   49 |        16 |  65 |                     97 |
| Cascade   |    6 |         3 |   9 |                     15 |
| Lookup    |    4 |         2 |   6 |                     10 |
| **Total** |   59 |        21 |  80 |                    122 |


### Comparison to Rescue-Prime Optimized

To make an apples-to-apples comparison we restrict the degree of the AIR to two, and add columns as necessary.

For Tip5 this means we have to add 3 columns per state element that undergoes the forward $\alpha$ th power map. The first contains the square, the second the fourth power, the third the sixth power; the seventh power is used directly in the transition constraint since it is now quadratic. Accordingly, this induces 3 new consistency constraints. There are 12 columns that need to be expanded in this way. So the total number of base columns is 55 + 3⋅12 = 91. The total number of columns is then 112 technically or 154 in B-field equivalents.

For Rescue-Prime and Rescue-Prime Optimized there are 16 columns that need to be expanded in this way.The total number of base columns is 16 + 16⋅3 = 64. The total number of columns is the same, 64, whether in technical terms of B-field equivalent terms.

Note that for the parameters here, Rescue-Prime has 8 rounds and as a result the trace of one hash function invocation does not fit into 8 rows. To accommodate for this, one must either include columns for counting the round, or expand the trace into 16 rows and use periodic constraints or periodic interpolants.

## Performance

These benchmarks were obtained on a Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz. On this machine Tip5 is 12.19× faster than Rescue-Prime Optimized. The implementation is available at [10].

| Hash Function          |      time |
|:-----------------------|----------:|
| Rescue-Prime           | 18.186 µs |
| Rescue-Prime Optimized | 14.357 µs |
| Poseidon               |  6.940 µs |
| Tip5                   |  0.851 µs |

## Security

### Statistical Differential Attack

The MDS matrix guarantees that in every consecutive pair of rounds, at least $m+1$ S-boxes are differentially active. But in every consecutive pair of rounds, there are only $2s$ split-and-lookup maps, so at least $m+1-2s$ forward $\alpha$-th power map must be differentially active. The probability that a differential characteristic is satisfied across two rounds is therefore at most $\left( \frac{\alpha - 1}{p} \right)^{m+1-2s}$. For the given parameters this probability is smaller than $2^{-552}$.


### Gröbner Basis Attacks

There are $m(N+1)$ wires of which $c$ are set to zero initially and $d$ are given by the digest, so $m(N+1)-c-d$ in total. There are as many equations. Their degrees are

 1. $p-1$ (or close to $p-1$) if it describes a split-and-lookup map;
 2. $\alpha$ if it describes a forward $\alpha$-th power map.

The Macaulay bound exceeds $p$. Therefore it pays to add the field equation $x^p - x$ for every variable $x$. This addition has the effect of restricting the degree to $p-1$ in every variable.

Macaulay matrix at this degree has $\binom{p-1}{m(N+1)-c-d}$ columns and as many rows. Assuming that the matrix is dense, finding a kernel vector using sparse linear algebra methods takes this number *squared* operations. For one round and setting the other parameters as above, this square is approximately equal to $2^{2557}$.

### Linear Approximation

The complexity of a Gröbner basis attack drops dramatically if the split-and-lookup maps are replaced with their best linear approximations. The resulting solution represents a successful attack (i.e., a (second) preimage or a collision) if it happens to coincide with the variety of the exact system of polynomials, i.e., without approximations. By modeling the solution found via polynomial system solving as a random element from the approximate variety, it is possible to estimate the probability that it lives also in the exact variety. Specifically: we count the number of approximate maps and the number of points they agree with their targets in.

One linear approximation to the split-and-lookup map agrees in 240 points, corresponding to the 2 fixed points of $L$, repeated 8 times, except for 16 values that can't be reached because they correspond to 64-bit integers greater than $p$. Inside 1 round there are $s$ split-and-lookup maps and the probability that they all send one of these agreeable points to their correct destination is $\left(\frac{240}{p}\right)^s$. For the given parameters this probability is less than $2^{-224}$ in one round. In other words, if we were to attack a single round with this technique, the produced solution would be correct (i.e., a valid (second) preimage or collision) with this probability.

Barring cancellations of approximation errors, and assuming that the state vectors are independent and uniform before they enters into a round, the probability of correct approximation drops exponentially in the number of rounds. Excluding the first and last round one estimates this probability at $\left(\frac{240}{p}\right)^{(N-2)s} \approx 2^{-673}$. 

### Fixing

Another technique to leverage Gröbner basis techniques consists of fixing at random the values on the wires into and out from the split-and-lookup S-boxes. Where the standard polynomial model of the cipher consists of high degree polynomials but as a system of equations has degree but $r-d = 5$ degrees of freedom (assuming preimage search); after fixing it consists of low degree polynomials but $r-d-Ns = -15$ degrees of "freedom". A random system of equations with this degree of over-determinedness can be expected to have a solution with probability on the order of $p^{-15} \approx 2^{960}$.

## Test Vectors

### Fixed-Length Hashing

```
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0] -> [941080798860502477, 5295886365985465639, 14728839126885177993, 10358449902914633406, 14220746792122877272]
[941080798860502477, 5295886365985465639, 14728839126885177993, 10358449902914633406, 14220746792122877272, 0, 0, 0, 0, 0] -> [15888421881075650037, 8699648354187865464, 6719068786850902915, 16188941274693647820, 4768361305800190493]
[941080798860502477, 15888421881075650037, 8699648354187865464, 6719068786850902915, 16188941274693647820, 4768361305800190493, 0, 0, 0, 0] -> [11494362724359741120, 2984169814429715553, 11021746812971026026, 5102281498552384717, 5023112854146751042]
[941080798860502477, 15888421881075650037, 11494362724359741120, 2984169814429715553, 11021746812971026026, 5102281498552384717, 5023112854146751042, 0, 0, 0] -> [627201255727529993, 2530132417472465719, 15134374672529870482, 10586143339158028166, 13810271029904013559]
[941080798860502477, 15888421881075650037, 11494362724359741120, 627201255727529993, 2530132417472465719, 15134374672529870482, 10586143339158028166, 13810271029904013559, 0, 0] -> [4790238723037855394, 13717377209729127271, 8994982932799814404, 18004412270774820131, 5877166878145340765]
[941080798860502477, 15888421881075650037, 11494362724359741120, 627201255727529993, 4790238723037855394, 13717377209729127271, 8994982932799814404, 18004412270774820131, 5877166878145340765, 0] -> [16959020643814878453, 12118009629857908438, 10239930869937551135, 6889489196156760098, 5774309862903741805]
[941080798860502477, 15888421881075650037, 11494362724359741120, 627201255727529993, 4790238723037855394, 16959020643814878453, 12118009629857908438, 10239930869937551135, 6889489196156760098, 5774309862903741805] -> [10869784347448351760, 1853783032222938415, 6856460589287344822, 17178399545409290325, 7650660984651717733]

```

### Variable-Length Hashing

```
[] -> [2335476311349343808, 1307299401243390569, 3414029282375928929, 2141465175172981451, 5966553798353564426]
[0] -> [4843866011885844809, 16618866032559590857, 18247689143239181392, 7637465675240023996, 9104890367162237026]
[0, 1] -> [14221897462292645957, 3690523333672640544, 7547831217417524560, 11517644941222042877, 16820478393376780897]
[0, 1, 2] -> [3557614275028747325, 18213566888269431883, 14211012637913216818, 18426990445135603349, 8015183961235958327]
[0, 1, 2, 3] -> [13668806558765160443, 7736989284450687030, 15316066412582144917, 14566815392725049262, 1631258856522889875]
[0, 1, 2, 3, 4] -> [1380324360087351655, 2493688017679385677, 18197583438743680153, 2303632749506762680, 2500436438073253576]
[0, 1, 2, 3, 4, 5] -> [1612925275097886605, 8293210493469698946, 5378029315601990928, 9997723552534409936, 18350405537085446855]
[0, 1, 2, 3, 4, 5, 6] -> [2368572306594843451, 13479396176400056076, 5509084167070310636, 9541200077614575285, 14698893519125746147]
[0, 1, 2, 3, 4, 5, 6, 7] -> [5764047891359019962, 4580068493600531946, 6759906304791724061, 17885774121391644741, 5272177385407180638]
[0, 1, 2, 3, 4, 5, 6, 7, 8] -> [5188069162914592397, 852189275605886954, 1770154650497175879, 10044069521465249269, 15310276722084590255]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] -> [10860102820350902073, 3915608745157093269, 13265162356636976960, 12884539544495432239, 18250298222337636025]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] -> [3600244007352627316, 15303906186770454737, 1015726521824820528, 66356695027375855, 5779592616064148896]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] -> [1060404084043899635, 648874805963137723, 1894483562712912060, 5433811877240427773, 7806886414290452621]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] -> [14652184199929954917, 11633498631025654684, 14139269421280747446, 7093472948163025260, 15211193950033777039]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] -> [1305246756860627865, 18438460485869922547, 7494110627966922360, 7548593716051627601, 4358538341446018656]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] -> [10410739531373060674, 13771109920827720164, 7182875134059861166, 3198837976822036466, 18186033490913067244]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] -> [14929361704838508901, 11687741109128592453, 10382568582765447962, 7356261893069094178, 16555487120057131546]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] -> [16861704039385090833, 17359803853352592839, 8736774648012811938, 13927213321560187738, 4613737635744171194]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17] -> [17603556615486733833, 8872323630341504237, 11715105888942673288, 2027392082169855751, 7469631507824032533]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] -> [7832476196531064929, 6690714694002917105, 3218657518291848622, 1745231362802374163, 7029621666171291710]
sum of digests: [6483667016211232820, 1120398765245047030, 9375424207996641714, 17770540514093105302, 17391179748947955]
```

## References

[1]: https://www.iacr.org/cryptodb/data/paper.php?pubkey=3167
[2]: https://eprint.iacr.org/2019/426
[3]: https://eprint.iacr.org/2020/1143
[4]: https://eprint.iacr.org/2021/1038
[5]: https://eprint.iacr.org/2020/315
[6]: https://eprint.iacr.org/2022/1577
[7]: https://eprint.iacr.org/2022/1530
[8]: https://eprint.iacr.org/2022/274
[9]: https://eprint.iacr.org/2016/504
[10]: https://github.com/Neptune-Crypto/twenty-first/blob/master/twenty-first/src/tip5/mod.rs
