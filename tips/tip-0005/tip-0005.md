# TIP 0005: Hash Function

| TIP            | 0005                                             |
|:---------------|:-------------------------------------------------|
| authors:       | Alan Szepieniec and Alexander Lemmens and Bobbin Threadbare |
| title:         | Tip5 Hash Function                                    |
| status:        | work in progress                                 |
| created:       | 2022-11-17                                       |
| issue tracker: | - |
| pdf:           | -                     |

**Abstract.**
This note proposes a new arithmetization-oriented hash function. It uses the SHARK design strategy [1] in combination with lookup tables, and is defined over the field with $p=2^{64}-2^{32}+1$ elements. This note also discusses techniques for efficiently arithmetizing the hash function.

## Introduction

In the space of arithmetization-oriented hash function, two design strategies stand out.

 1. The Marvellous design strategy [2], best known for its member Rescue-Prime [3], introduced the idea of alternating S-box layers where even layers compute low-degree permutations in one direction and odd layers compute low-degree permutations in the opposite direction. As a result, a small number of rounds guarantees that the algebraic degree of the cipher is sufficiently high when attacked from any direction. Moreover, in the specific case of Rescue-Prime, two consecutive S-box layers can be folded together into one low-degree arithmetization. This folding technique yields essentially two rounds of the cipher for the price of one cycle in the arithmetic virtual machine. Since the publication of the Marvellous design strategy, there has been very little progress in cryptanalyzing Rescue and Rescue-Prime.

 2. Reinforced Concrete [4] introduced the use of lookup tables in an otherwise arithmetization-oriented cipher. The lookup table can be evaluated efficiently on CPUs as well as proven efficiently in a zero-knowledge or succinctly verifiable proof system using Plookup [5] or techniques derived from there. Moreover, represented as polynomials over a finite field, non-trivial lookup tables have maximal degree. Therefore, the use of lookup tables provides a robust way to resist algebraic attacks including attacks relying on Gröbner bases. The downside of this technique is that the lookup tables cannot be too large; that therefore the field elements must be decomposed into chunks which are then looked up; and that the prover must establish the correct decomposition and recomposition of these chunks. This process leads to an expensive arithmetization and does not generalize well to arbitrary fields.

This note proposes a new hash function. It uses the SHARK design strategy, on which Marvellous is based, of using full S-box layers interleaved with MDS matrices. This strategy ensures resistance against statistical attacks. The S-box is built from a table lookup that computes the cube map in $\mathbb{F}_{2^{8}+1}$ but offset by one. In addition to being fast to compute, this function makes the algebraic degree large and provides resistance against Gröbner basis attacks. This note also includes a discussion about how to avoid paying high costs when arithmetizing the hash function in a STARK.

*Acknowledgements.* Many of the ideas used in this note came were first discussed in the course of the Rescue-Prime Optimization project [6].

## Specification

### Basic Parameters 

| Parameter | Symbol | Value |
|-----------|--------|-------|
| field modulus | $p$ | $2^{64} - 2^{32} + 1$ |
| number of rounds | $N$ | 5 |
| state size | $m$ | 16 |
| sponge rate | $r$ | 10 |
| sponge capacity | $c$ | 6 |
| digest length | $d$ | 5 |
| power map exponent | $\alpha$ | 7|
| number of split-and-lookups per round | $s$ | 4 |

For the sake of genericity the rest of the note uses the symbol rather than the value.

### S-Box

There are two types of S-boxes. One is the regular forward $\alpha$-th power map already used in Rescue-Prime. The second type is more involved and may be called the split-and-lookup map. Every round consists of one S-box layer; in this layer the first $s$ state elements are mapped by the split-and-lookup map and the second $m-s$ state elements are mapped by the forward $\alpha$-th power map.

The split-and-lookup map is defined as follows:

$$ S : \mathbb{F}_p \rightarrow \mathbb{F}_p,  x \mapsto R^{-1} \cdot \rho \circ L^8 \circ \sigma  (R \cdot x) $$

The components are:

 - $R$ is the field element congruent to $2^{64}$ modulo $p$, accounting for native representation of field elements in Montgomery form.
 - $\sigma : \mathbb{F}_p \rightarrow \mathbb{F}_p^8, x \mapsto (a, b, c, d, e, f, g, h)$ where all outputs are at most 8 bits wide and $x = a + 2^{8} \cdot b + 2^{16} \cdot c + 2^{24} \cdot d + 2^{32} \cdot e + 2^{40} \cdot f + 2^{48} \cdot g + 2^{56} \cdot h$.
 - $L : \mathbb{F}_ p \rightarrow \mathbb{F}_ p$ is defined only for field elements that are at most 8 bits wide. Identifying this subset of $\mathbb{F}_ p$ with $\mathbb{F}_ {2^{8}+1}$, the lookup table $L$ computes $L : \mathbb{F}_ {2^{8}+1} \rightarrow \mathbb{F}_ {2^{8}+1}, x \mapsto (x+1)^3-1$.
 - $\rho : \mathbb{F}_ p^8 \rightarrow \mathbb{F}_ p$ computes the inverse of $\sigma$.

The inverse of this S-box is $x \mapsto R \cdot \rho \circ (L^{-1})^4 \circ \sigma (R^{-1} \cdot x)$.

One input-output pair is noteworthy $S(-1) = -1$.

### Remaining Specifications

A single round consists of three steps:

 1. A full S-box layer, in which the function $S(x)$ is applied to every element of the state.
 2. Matrix-vector multiplication of the MDS matrix with the state (as the column vector). The MDS matrix is circulant, giving rise to fast matrix-vector products. When $m=16$, the MDS matrix is the one given by the Rescue-Prime Optimized report, namely the circulant matrix whose first row is `[256, 2, 1073741824, 2048, 16777216, 128, 8, 16, 524288, 4194304, 1, 268435456, 1, 1024, 2, 8192]`.
 3. Addition of constants. A preselected random constant is added into every element of the state.

The constants are determined by expanding the ASCII string "`TIP 5`" into $9 m N$ bytes using SHAKE256. Every 9-tuple corresponds to a positive integer by interpreting the first byte as the most significant digit in base 256. Every such integer determines a field element via reduction modulo $p$. The $(mi + j)$ th field element is the constant for the $j$ th state element in the $i$ th round.

The permutation $P$ consists of $N$ rounds. The hash function is obtained by instantiating the sponge construction with the permutation $P$ and truncating the output to length $d$.

## Lookup Argument

There are two tables in the arithmetic execution trace. The Hash Table computes the hash function by applying the round function to the state in every cycle. The looked up elements appear nondeterministically in this trace. The second table is the Lookup Table, which contains all input-output pairs. A lookup argument establishes that the set of all input-output pairs in the Hash Table is a subset of all input-output pairs in the Lookup Table. For the purpose of presenting this lookup argument, we pretend as though the hash table has only one lookup per row.

### Bézout Argument

Using random weights from the verifier `a, b`, the input and output columns are compressed into one random linear combination. It then suffices to show that the set of random linear combinations used by the Hash Table, is a subset of the random linear combinations in the lookup table.

Let $\lbrace \texttt{rlc}_i \rbrace_i$ denote the set of input-output pairs, each compressed into a random linear combination sing `a` and `b`, that are looked up at least once. The Hash Table and Lookup Table both define a product polynomial whose factors are random linear combinations offset by $X$.

$$ \texttt{rph}(X) = \prod_i (\texttt{rlc}_i - X)^{m_i} $$

$$ \texttt{rpl}(X) = \prod_i (\texttt{rlc}_i - X) $$

The difference between these two polynomials is the multiplicities $m_i$ of their roots, which is 1 for the Lookup Table and possible greater than 1 for the Hash Table. The letter `r` suggests that these values of these polynomials in $\alpha$ can be computed by *running product* columns, once $\alpha$ is known. But merely comparing the values $\texttt{rph}(\alpha)$ and $\texttt{rpl}(\alpha)$ does not suffice – the multiplicities of the roots are different.

The following Bézout relation argument eliminates these multiplicities, enabling a test for subset relationship by probing a polynomial identity in the random point $\alpha$.

In addition to a *running product*, the Hash Table defines a *formal derivative*. Let $\texttt{fdh}(X)$ denote this polynomial:

$$ \texttt{fdh}(X) = \sum_i m_i (X - \texttt{rlc}_i)^{m_i - 1} \prod_{j \neq i} (X - \texttt{rlc}_j)^{m_j} = \frac{d}{dX} \texttt{rph}(X) $$

Likewise, the Lookup Table defines a formal derivative as well, except this one is weighted by multiplicity:

$$ \texttt{mwfdl}(X) = \sum_i m_i \prod_{j \neq i} (X - \texttt{rlc}_j) $$

On the side of the Hash Table, the running product and its formal derivative satisfy the following Bézout relation: $\texttt{rph}(X) \cdot x(X) + \texttt{fdh}(X) \cdot y(X) = g(X)$, where $g(X)$ is the greatest common divisor and $x(X)$ and $y(X)$ are Bézout coefficient polynomials. Then $\frac{\texttt{rph}(X)}{g(X)}$ is the square-free polynomial with the same roots as $\texttt{rph}(X)$, and equal to $\texttt{rpl}(X)$ of the Lookup Table. Moreover, a similar relationship holds for the formal derivatives: $\texttt{fdh}(X) / g(X) = \texttt{mwfdl}(X)$. By eliminating $g(X)$ we get the identity of polynomials $\texttt{rph}(X) \cdot \texttt{mwfdl}(X) = \texttt{fdh}(X) \cdot \texttt{rpl}(X)$. The objective is to test this identity in the random point $\alpha$.

The cheating prover who uses an input-output pair not in the lookup table must use a polynomial $\texttt{rph}(X)$ with at least one root that $\texttt{rpl}(X)$ does not share. As a result, the polynomial identity is not satisfied because this root occurs in the left hand side with multiplicity one greater than in the right hand side. By the Schwarz-Zippel lemma, the probability that the identity holds in the random point $\alpha$ is at most $\frac{(1 + m/2) T}{|\mathbb{F}|}$, where $T$ is the padded height of the table.

### Optimization with Logarithmic Derivatives

The above intuition gives rise to an AET and AIR for checking it. Indeed, the values `rph(α)`,`fdh(α)`, `rpl(α)`, and `mwfdl(α)` can all be computed via running accumulator columns. However, it turns out there is an optimization that reduces the number of columns at the expense of a batch-inversion. This optimization is inspired by Haböck's lookup argument [7] but ultimately that argument is tailored to Multilinear IOPs. The present optimization can be seen as lifting that technique to the AET/AIR setting, albeit derived differently.

The logarithmic derivative of a polynomial $f(X)$ is defined as $\frac{f'(X)}{f(X)}$. The logarithmic derivative is so named because the logarithmic derivative of the product of two polynomials is the sum of their logarithmic derivatives: $\frac{\mathsf{d}(f(X)g(X))}{f(X)g(X)\mathsf{d}X} = \frac{f'(X)g(X)}{f(X)g(X)} + \frac{f(X)g'(X)}{f(X)g(X)} = \frac{f'(X)}{f(X)} + \frac{g'(X)}{g(X)}$.

Observe that the polynomial identity

$$ \texttt{rph}(X) \cdot \texttt{mwfdl}(X) = \texttt{fdh}(X) \cdot \texttt{rpl}(X) $$

can be re-written in terms of logarithmic derivatives:

$$ \frac{\texttt{fdh}(X)}{\texttt{rph}(X)} = \frac{\texttt{mwfdl}(X)}{\texttt{rpl}(X)} = \sum_i \frac{m_i}{X - \texttt{rlc}_i} .$$

On the side of the Lookup Table, two columns are needed to probe this identity in the random point $\alpha$.

 - the running product `rph` and multiplicity-weighted formal derivative `mwfdh` are merged into the single extension column `sum`, which contains the running sum of `mul / (α - rlc)`;
 - base column `mul` contains the multiplicity with which the given row is queried.

On the Hash Table only *one* extension column is needed. Specifically, the running product `rph` and formal derivative `fdh` are merged into a single column, the logarithmic derivative `ldh`.

To update `ldh`, recall that the standard running product column `rph` is defined to accumulate one *factor* in every row. Moreover, `ldh` is defined to contain the logarithmic derivative of `rph` in every row, so we can use the eponymous property to populate it. Speficially, the would-have-been running product update rule `rph* = rph * (α - rlc*)` becomes `ldh* = ldh + 1/(α - rlc*)`, where the asterisk `*` indicates the respective element from the next row.

The update rules `sum* = sum + mul* / (α - rlc*)` and `ldh* = ldh + 1 / (α - rlc*)` can be converted to AIR constraints by multiplying left and right hand sides by `(α - rlc*)`. 

## Arithmetization

### Hash Table

Since $N = 5$ is not one less than a power of two, explicit columns are needed to keep track of the round number. Three columns suffice for this purpose.

Every lookup-input and every lookup-output must be explicitly represented. So $s$ field elements being mapped by the split-and-lookup S-box turn into $8 \cdot s$ columns. Let `lkin[i]` and `lkout[i]` with `i in {0, ..., s-1}` denote these columns. For each pair `(lkin[i], lkout[i])` there is 1 extension columns, `ldh[i]`. The purpose of this extension column will be clarified later.

### Lookup Table

To establish the correct contents of the Lookup Table, it suffices to compute one running evaluation in an extension column `re`. As there are only 256 elements of the table and as all are known to the verifier, the verifier can compute the terminal value of this running evaluation locally. This construction gives rise to one initial constraint, one transition constraint, and one terminal constraint.

### Lookup Argument

## Performance

These benchmarks were obtained on a Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz. On this machine Tip5 is 11.26× faster than Rescue-Prime Optimized.

| Hash Function | time |
|---------------|------|
| Rescue-Prime  | 21.501 µs |
| Rescue-Prime Optimized | 14.139 µs |
| Tip5 | 1.2553 µs |

## Security

### Statistical Differential Attack

The MDS matrix guarantees that in every consecutive pair of rounds, at least $m+1$ S-boxes are differentially active. But in every consecutive pair of rounds, there are only $2s$ split-and-lookup maps, so at least $m+1-2s$ forward $\alpha$-th power map must be differentially active. The probability that a differential characteristic is satisfied across two rounds is therefore at most $\left( \frac{\alpha - 1}{p} \right)^{m+1-2s}$. For the given parameters this probability is smaller than $2^{-552}$.


### Gröbner Basis Attacks

There are $m(N+1)$ wires of which $c$ are set to zero initially and $d$ are given by the digest, so $m(N+1)-c-d$ in total. There are as many equations. Their degrees are

 1. $p-1$ (or close to $p-1$) if it describes a split-and-lookup map;
 2. $\alpha$ if it describes a forward $\alpha$-th power map.

The Macaulay bound exceeds $p$. Therefore it pays to add the field equation $x^p - x$ for every variable $x$. This addition has the effect of restricting the degree to $p-1$ in every variable.

Macaulay matrix at this degree has $\binom{p-1}{m(N+1)-c-d}$ columns and as many rows. Assuming that the matrix is dense, finding a kernel vector using sparse linear algebra methods takes this number *squared* operations. For one round and setting the other parameters as above, this square is approximately equal to $2^{2557}$.

### Linear Approximation

The complexity of a Gröbner basis attack drops dramatically if the split-and-lookup maps are replaced with their best linear approximations. The resulting solution represents a successful attack if it happens to coincide with the variety of the actual system of polynomials, i.e., without approximations. By modeling the solution as a random element from the approximate variety, it is possible to estimate the probability that it lives in the exact variety as well by counting the number of approximate maps and the number of points they agree with their targets in.

One linear approximation to a split-and-lookup map agrees in 240 points, corresponding to the 2 fixed points of $L$, repeated 8 times, except for 16 values that can't be reached because they correspond to 64-bit integers greater than $p$. Inside 1 round there are $s$ split-and-lookup maps and the probability that they all send one of these agreeable points to their correct destination is $\left(\frac{240}{p}\right)^s$. For the given parameters this probability is less than $2^{-224}$ in one round.

## Test Vectors

## References

[1]: https://www.iacr.org/cryptodb/data/paper.php?pubkey=3167
[2]: https://eprint.iacr.org/2019/426
[3]: https://eprint.iacr.org/2020/1143
[4]: https://eprint.iacr.org/2021/1038
[5]: https://eprint.iacr.org/2020/315
[6]: https://eprint.iacr.org/2022/1577
[7]: https://eprint.iacr.org/2022/1530