# TIP 0009: Polynomial Acceleration

| TIP            | 0009                                             |
|:---------------|:-------------------------------------------------|
| authors:       | Alan Szepieniec                                  |
| title:         | Polynomial Acceleration                          |
| status:        | draft                                            |
| created:       | 2024-01-18                                       |
| issue tracker: | <https://github.com/TritonVM/triton-vm/pull/219> |

**Abstract** This note describes an improvement to Triton VM (or STARK VMs in general)
whereby the VM can perform arithmetic operations on polynomials in addition to operations on field elements. The correct evolution of the values contained by polynomial-registers is ensured through an AIR constraint system collapsing the polynomials in question to their evaluations in a random point supplied by the verifier. Extending the power of polynomial arithmetic to the VM has the potential to reduce the cost of key steps in the context of recursive verification and other complex tasks, such as
 - the low degree test of an explicit codeword;
 - the verification of the correct evaluation of a circuit;
 - continuations, enabling the segmentation of a long-winded computation into segments that can be proven separately before being joined through recursion;
 - single-instruction multiple-data instructions in general;
 - the verification of a number-theoretic transform;
 - big-integer operations.

# Introduction

The STARK proof system traditionally certifies the correct evolution of a set of registers
by reducing the satisfaction of the AIR constraints (that define what "correct evolution"
means) on a given domain of interest, to a clean division of polynomials. Two features of this description are
noteworthy, First, the values these registers can take live in a *finite field*. Second, the
AIR constraints are *local*: they relate all tuples of states with an distance
pattern that is both static and independent of the total evolutionary length -- typically:
pairs of consecutive states.

To overcome the limitation of locality, it suffices to define another trace which
contains or pertains to the same underlying data but differs in terms
of its dimension of evolution. The different dimensions of evolution, e.g., time versus
address space, induce different notions of locality, which can be captured by different 
distance patterns and thus different AIR constraints.

A round of interaction with the verifier suffices to establish the correct relation
between the two *a priori* distinct traces. The verifier supplies randomness, which is 
then used to populate additional auxiliary columns in the trace whose purpose is to
capture some aggregate quantity. Auxiliary AIR constraints certify the correct values in
these auxiliary columns. The Schwartz-Zippel lemma bounds the probability that the 
matching aggregate quantities of two distinct traces agree despite originating from disparate data sets.

In this note we analyze the first noteworthy feature. Phrased as a limitation to be overcome,
the question becomes: *what other values can registers take, beyond finite field elements?*

This note supplies an answer: *univariate polynomials over the finite field*.

Intuitively,
the virtual machine gets symbolic access to the randomness that will be sampled by the 
verifier. Since the virtual machine does not know the value of this symbol, any arithmetic
done on it must be represented symbolically â€“ in the form of a polynomial or a circuit.

While the AIR constraints could in principle be lifted from a circuit whose inputs are
field elements to a circuit whose inputs are polynomials, the point of composing the AIR
with the interpolants of the trace is to obtain univariate polynomials which are then
proven to have  low degree using FRI. If the AIR is lifted to take univariate polynomials,
this composition will result in bivariate polynomials for which no low degree test is
known.

Therefore, instead of lifting the AIR, the symbolic polynomials are collapsed using 
evaluation in a random point supplied by the verifier. Now the AIR applies, as usual, to a
vector of field elements.

Extending a virtual machine architecture with polynomial arithmetic presents a number of
challenges. 

 - A typical set of instructions include instructions that are not friendly to
   polynomials, such as range-checks or hashing; these instructions must be barred somehow
   from applying to polynomials.
 - A typical architecture layout consists of several independent logical units that
   communicate data to one another. This communication channel must either disallow 
   the transmission of polynomials or all logical units that are party to it must support
   them. 
 - In order to justify using the Fiat-Shamir transform, there must be enough entropy in
   the first message sent by the prover, which commits to the part of the trace that is
   independent of the polynomials.
 - An obvious primitive to be supported in the context of univariate polynomials is
   testing their low degree. Including a dynamic number of dynamically-defined polynomials
   in the FRI low degree test raises questions regarding soundness.

To address these challenges this note suggests to contain all polynomial arithmetic within
a single logical unit called the *Univariate Polynomial Coprocessor (UPC)*. Specifically,
this note suggests a concrete architecture for this coprocessor and concrete integration
with the rest of the architecture of Triton VM.

# Architecture

## High-Level Perspective

The proposed change introduces a new arithmetic/logical unit called the UPC. Conceptually the new unit is distinct from the processor but from the point of view of arithmetization it may be merged into the same table. There is no need to expand a single cycle or row on the processor into multiple cycles or rows on the univariate polynomial coprocessor, and merging the two tables has the additional benefit of obviating the communication bus that would otherwise be needed.

The UPC consists of 3 + 1 + `NUM_POLYNOMIAL_REGISTERS` + 2 + 2 registers, divided into four groups:
 1. Register indicators.
   - `lhs` the left-hand-side of the polynomial operation, indicating a polynomial register
   - `rhs` the right-hand-side of the polynomial operation, indicating a polynomial register
   - `dest` the destination of the polynomial operation, indicating a polynomial register
 2. Low degree accumulator. This registers serves to prove the low degree of polynomials that arise in the course of some computation. 
   - `acc` is a *bivariate* polynomial (in $X$ and $Y$) over the *extension field* that accumulates one univariate polynomial (in $X$) every time a new polynomial arises whose low degree must be proven. Specifically, every time a new polynomial $f(X)$ arises, this register is modified as $\mathtt{acc} \mapsto Y \cdot \mathtt{acc} + f(X)$.
 3. Polynomial registers. In the first round of interaction, these registers take values from the univariate polynomial ring (in $X$) over the *base* field. In the second round of interaction, these registers take values from the extension field.
   - `pr0`
   - ...
   - `prn` where `n = NUM_POLYNOMIAL_REGISTERS-1`.
 4. Produce. These registers hold up to two result-values which live in the univariate ring over the *extension field*.
   - `res0`
   - `res1`.
 5. Degree trackers. For the register and produce polynomials it is necessary to track their degrees. We do this with a register that contains the monomial $X^{d}$.
   - `pr0_deg`
   - ...
   - `prn_deg`
   - `res0_deg`
   - `res1_deg`.

The indeterminates $X$ and $Y$ are symbolic values and the polynomials in them are represented symbolically. After the first round of interaction, $X$ and $Y$ are substituted for $\alpha$ and $\beta$, respectively.

The reason why the accumulation of intermediate results into `acc` certifies that they are indeed low degree is because the univariate polynomial $\mathtt{acc}(X, \beta)$ represents a random linear combination of all accumulated polynomials, weighted by powers of $\beta$. This codeword associated with this univariate polynomial is included in the linear combination of codewords that goes into FRI. The DEEP out-of-domain row includes an evaluation of $\mathtt{acc}(X,\beta)$ in the out-of-domain point, which coincides with $X = \alpha$.

The following instructions make use of the univariate polynomial coprocessor. The involved registers are indicated by the instruction argument, which in the general case can take values from `0` to `NUM_POLYNOMIAL_REGISTERS^3 - 1`.

 - `poly_add` adds two polynomials and stores the result.
 - `poly_mul` multiplies two polynomials and stores the result.
 - `poly_div` performs long division on two polynomials and stores the result.
 - `poly_mod` adds two polynomials and stores the result.
 - `poly_eval` evaluates a polynomial in a given (by the opstack) extension field element and returns (to the processor) the result.
 - `poly_copy` copies a polynomial from one register to another.
 - `poly_shift` multiplies a polynomial by some power of $X$.
 - `poly_assemble` assembles a polynomial out of the few opstack elements by interpreting them as coefficients, and stores the result.
 - `poly_asa` assembles one polynomial, and adds it to the shift of another.

For brevity we focus on only on the mechanics of `poly_mod` as the other instructions are either similar or simple enough to exempt from explicit treatment.

The instruction `poly_mod` takes an immediate argument which decomposes into three indices of polynomial registers, respectively the two inputs and the output of the operation. Let $n(X)$ and $d(X)$ denote the polynomials contained by the indicated inputs; there is an AIR expression to capture this polynomial. The registers `res0` and `res1` are populated with the polynomials $q(X)$ and $r(X)$ such that $n(X) = q(X) \cdot d(X) + r(X)$ and such that $\deg(q) \leq \deg(n)$ and $\deg(r) < \deg(d)$. The result $r(X)$ is copied from `res1` to the indicated register. Into `acc` are accumulated:
 - `res0`
 - `res1`
 - $X^N \cdot$ `res0_deg`$^{-1}$ â‹… `res0`
 - $X^N \cdot$ `res1_deg`$^{-1}$ â‹… `res1`
 - `prn` â‹… `res1_deg`$^{-1}$ where `prn` denotes the register containing $n(X)$
 - `prd` â‹… `res0_deg`$^{-1} \cdot X^{-1}$ where `prd` denotes the register containing $d(X)$.

# Applications