use std::fmt::Display;
use std::fmt::Formatter;
use std::fmt::Result as FmtResult;
use std::mem::MaybeUninit;

use itertools::Itertools;
use ndarray::parallel::prelude::*;
use ndarray::Array1;
use ndarray::ArrayView1;
use ndarray::ArrayView2;
use ndarray::ArrayViewMut2;
use ndarray::Axis;
use twenty_first::prelude::*;
use twenty_first::shared_math::mpolynomial::Degree;
use twenty_first::shared_math::traits::FiniteField;

use crate::arithmetic_domain::ArithmeticDomain;
use crate::table::challenges::Challenges;
use crate::table::master_table::MasterExtTable;

/// The implementations of these functions are automatically generated using the
/// command `cargo run --bin constraint-evaluation-generator` and live in
/// `constraints.rs`.
pub trait Evaluable<FF: FiniteField> {
    /// The code for this method must be generated by running
    /// `cargo run --bin constraint-evaluation-generator`
    fn evaluate_initial_constraints(
        base_row: ArrayView1<FF>,
        ext_row: ArrayView1<XFieldElement>,
        challenges: &Challenges,
    ) -> Vec<XFieldElement>;

    /// The code for this method must be generated by running
    /// `cargo run --bin constraint-evaluation-generator`
    fn evaluate_consistency_constraints(
        base_row: ArrayView1<FF>,
        ext_row: ArrayView1<XFieldElement>,
        challenges: &Challenges,
    ) -> Vec<XFieldElement>;

    /// The code for this method must be generated by running
    /// `cargo run --bin constraint-evaluation-generator`
    fn evaluate_transition_constraints(
        current_base_row: ArrayView1<FF>,
        current_ext_row: ArrayView1<XFieldElement>,
        next_base_row: ArrayView1<FF>,
        next_ext_row: ArrayView1<XFieldElement>,
        challenges: &Challenges,
    ) -> Vec<XFieldElement>;

    /// The code for this method must be generated by running
    /// `cargo run --bin constraint-evaluation-generator`
    fn evaluate_terminal_constraints(
        base_row: ArrayView1<FF>,
        ext_row: ArrayView1<XFieldElement>,
        challenges: &Challenges,
    ) -> Vec<XFieldElement>;
}

pub trait Quotientable: Evaluable<BFieldElement> {
    const NUM_INITIAL_CONSTRAINTS: usize;
    const NUM_CONSISTENCY_CONSTRAINTS: usize;
    const NUM_TRANSITION_CONSTRAINTS: usize;
    const NUM_TERMINAL_CONSTRAINTS: usize;

    /// The total number of constraints. The number of quotients is identical.
    const NUM_CONSTRAINTS: usize = Self::NUM_INITIAL_CONSTRAINTS
        + Self::NUM_CONSISTENCY_CONSTRAINTS
        + Self::NUM_TRANSITION_CONSTRAINTS
        + Self::NUM_TERMINAL_CONSTRAINTS;

    fn fill_initial_quotients(
        master_base_table: ArrayView2<BFieldElement>,
        master_ext_table: ArrayView2<XFieldElement>,
        quot_table: &mut ArrayViewMut2<MaybeUninit<XFieldElement>>,
        zerofier_inverse: ArrayView1<BFieldElement>,
        challenges: &Challenges,
    ) {
        debug_assert_eq!(zerofier_inverse.len(), master_base_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), master_ext_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), quot_table.nrows());
        quot_table
            .axis_iter_mut(Axis(0))
            .into_par_iter()
            .enumerate()
            .for_each(|(row_index, quotient_table_row)| {
                let base_row = master_base_table.row(row_index);
                let ext_row = master_ext_table.row(row_index);
                Self::evaluate_initial_constraints(base_row, ext_row, challenges)
                    .into_iter()
                    .map(|numerator| numerator * zerofier_inverse[row_index])
                    .map(MaybeUninit::new)
                    .collect::<Array1<_>>()
                    .move_into(quotient_table_row);
            });
    }

    fn fill_consistency_quotients(
        master_base_table: ArrayView2<BFieldElement>,
        master_ext_table: ArrayView2<XFieldElement>,
        quot_table: &mut ArrayViewMut2<MaybeUninit<XFieldElement>>,
        zerofier_inverse: ArrayView1<BFieldElement>,
        challenges: &Challenges,
    ) {
        debug_assert_eq!(zerofier_inverse.len(), master_base_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), master_ext_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), quot_table.nrows());
        quot_table
            .axis_iter_mut(Axis(0))
            .into_par_iter()
            .enumerate()
            .for_each(|(row_index, quotient_table_row)| {
                let base_row = master_base_table.row(row_index);
                let ext_row = master_ext_table.row(row_index);
                Self::evaluate_consistency_constraints(base_row, ext_row, challenges)
                    .into_iter()
                    .map(|numerator| numerator * zerofier_inverse[row_index])
                    .map(MaybeUninit::new)
                    .collect::<Array1<_>>()
                    .move_into(quotient_table_row);
            });
    }

    fn fill_transition_quotients(
        master_base_table: ArrayView2<BFieldElement>,
        master_ext_table: ArrayView2<XFieldElement>,
        quot_table: &mut ArrayViewMut2<MaybeUninit<XFieldElement>>,
        zerofier_inverse: ArrayView1<BFieldElement>,
        challenges: &Challenges,
        trace_domain: ArithmeticDomain,
        quotient_domain: ArithmeticDomain,
    ) {
        debug_assert_eq!(zerofier_inverse.len(), master_base_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), master_ext_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), quot_table.nrows());

        // the relation between the quotient domain and the trace domain
        let unit_distance = quotient_domain.length / trace_domain.length;
        let domain_length_bit_mask = quotient_domain.length - 1;

        quot_table
            .axis_iter_mut(Axis(0))
            .into_par_iter()
            .enumerate()
            .for_each(|(current_row_index, quotient_table_row)| {
                // bitwise logical and `domain_length_bit_mask` performs the modulo operation:
                // `domain.length - 1` is a bit-mask with all 1s because `domain.length` is 2^k
                // for some k.
                let next_row_index = (current_row_index + unit_distance) & domain_length_bit_mask;
                Self::evaluate_transition_constraints(
                    master_base_table.row(current_row_index),
                    master_ext_table.row(current_row_index),
                    master_base_table.row(next_row_index),
                    master_ext_table.row(next_row_index),
                    challenges,
                )
                .into_iter()
                .map(|numerator| numerator * zerofier_inverse[current_row_index])
                .map(MaybeUninit::new)
                .collect::<Array1<_>>()
                .move_into(quotient_table_row);
            });
    }

    fn fill_terminal_quotients(
        master_base_table: ArrayView2<BFieldElement>,
        master_ext_table: ArrayView2<XFieldElement>,
        quot_table: &mut ArrayViewMut2<MaybeUninit<XFieldElement>>,
        zerofier_inverse: ArrayView1<BFieldElement>,
        challenges: &Challenges,
    ) {
        debug_assert_eq!(zerofier_inverse.len(), master_base_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), master_ext_table.nrows());
        debug_assert_eq!(zerofier_inverse.len(), quot_table.nrows());
        quot_table
            .axis_iter_mut(Axis(0))
            .into_par_iter()
            .enumerate()
            .for_each(|(row_index, quotient_table_row)| {
                let base_row = master_base_table.row(row_index);
                let ext_row = master_ext_table.row(row_index);
                Self::evaluate_terminal_constraints(base_row, ext_row, challenges)
                    .into_iter()
                    .map(|numerator| numerator * zerofier_inverse[row_index])
                    .map(MaybeUninit::new)
                    .collect::<Array1<_>>()
                    .move_into(quotient_table_row);
            });
    }

    fn initial_quotient_degree_bounds(interpolant_degree: Degree) -> Vec<Degree>;

    fn consistency_quotient_degree_bounds(
        interpolant_degree: Degree,
        padded_height: usize,
    ) -> Vec<Degree>;

    fn transition_quotient_degree_bounds(
        interpolant_degree: Degree,
        padded_height: usize,
    ) -> Vec<Degree>;

    fn terminal_quotient_degree_bounds(interpolant_degree: Degree) -> Vec<Degree>;
}

/// The type of constraint. Can be used to determine the degree bounds for the quotient
/// polynomials. Concretely, the degree of the zerofier polynomials differs between the
/// constraint types.
#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub(crate) enum ConstraintType {
    Initial,
    Consistency,
    Transition,
    Terminal,
}

impl Display for ConstraintType {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        match self {
            ConstraintType::Initial => write!(f, "initial"),
            ConstraintType::Consistency => write!(f, "consistency"),
            ConstraintType::Transition => write!(f, "transition"),
            ConstraintType::Terminal => write!(f, "terminal"),
        }
    }
}

/// Helps debugging and benchmarking. The maximal degree achieved in any table dictates the length
/// of the FRI domain, which in turn is responsible for the main performance bottleneck.
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub(crate) struct DegreeWithOrigin {
    pub degree: Degree,
    pub interpolant_degree: Degree,
    pub zerofier_degree: Degree,
    pub origin_index: usize,
    pub origin_table_height: usize,
    pub origin_constraint_type: ConstraintType,
}

impl Display for DegreeWithOrigin {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        assert!(self.degree > 0);
        let zerofier_corrected_degree = self.degree + self.zerofier_degree;
        let degree = zerofier_corrected_degree / self.interpolant_degree;
        let idx = self.origin_index;
        let constraint_type = self.origin_constraint_type;
        write!(
            f,
            "Degree of polynomial {idx:02} of type “{constraint_type}” is {degree}."
        )
    }
}

/// Compute the degrees of the quotients from all AIR constraints that apply to the table.
pub(crate) fn all_degrees_with_origin(
    interpolant_degree: Degree,
    padded_height: usize,
) -> Vec<DegreeWithOrigin> {
    let initial_degrees_with_origin =
        MasterExtTable::initial_quotient_degree_bounds(interpolant_degree)
            .into_iter()
            .enumerate()
            .map(|(origin_index, degree)| DegreeWithOrigin {
                degree,
                interpolant_degree,
                zerofier_degree: 1,
                origin_index,
                origin_table_height: padded_height,
                origin_constraint_type: ConstraintType::Initial,
            })
            .collect_vec();

    let consistency_degrees_with_origin =
        MasterExtTable::consistency_quotient_degree_bounds(interpolant_degree, padded_height)
            .into_iter()
            .enumerate()
            .map(|(origin_index, degree)| DegreeWithOrigin {
                degree,
                interpolant_degree,
                zerofier_degree: padded_height as Degree,
                origin_index,
                origin_table_height: padded_height,
                origin_constraint_type: ConstraintType::Consistency,
            })
            .collect();

    let transition_degrees_with_origin =
        MasterExtTable::transition_quotient_degree_bounds(interpolant_degree, padded_height)
            .into_iter()
            .enumerate()
            .map(|(origin_index, degree)| DegreeWithOrigin {
                degree,
                interpolant_degree,
                zerofier_degree: padded_height as Degree - 1,
                origin_index,
                origin_table_height: padded_height,
                origin_constraint_type: ConstraintType::Transition,
            })
            .collect();

    let terminal_degrees_with_origin =
        MasterExtTable::terminal_quotient_degree_bounds(interpolant_degree)
            .into_iter()
            .enumerate()
            .map(|(origin_index, degree)| DegreeWithOrigin {
                degree,
                interpolant_degree,
                zerofier_degree: 1,
                origin_index,
                origin_table_height: padded_height,
                origin_constraint_type: ConstraintType::Terminal,
            })
            .collect();

    [
        initial_degrees_with_origin,
        consistency_degrees_with_origin,
        transition_degrees_with_origin,
        terminal_degrees_with_origin,
    ]
    .concat()
}
