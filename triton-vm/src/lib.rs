//! Triton Virtual Machine is a Zero-Knowledge Proof System (ZKPS) for proving correct execution
//! of programs written in Triton assembly. The proof system is a zk-STARK, which is a
//! state-of-the-art ZKPS.

use triton_opcodes::program::Program;
pub use twenty_first::shared_math::b_field_element::BFieldElement;
pub use twenty_first::shared_math::tip5::Digest;
use twenty_first::shared_math::tip5::Tip5;
use twenty_first::util_types::algebraic_hasher::AlgebraicHasher;

pub use crate::proof::Claim;
use crate::proof::Proof;
use crate::stark::Stark;
pub use crate::stark::StarkParameters;
use crate::table::master_table::MasterBaseTable;

pub mod arithmetic_domain;
pub mod bfield_codec;
pub mod error;
pub mod fri;
pub mod op_stack;
pub mod proof;
pub mod proof_item;
pub mod proof_stream;
pub mod shared_tests;
pub mod stark;
pub mod table;
pub mod vm;

/// Prove correct execution of a program written in Triton assembly.
/// This is a convenience function, abstracting away the details of the STARK construction.
/// If you want to have more control over the STARK construction, this method can serve as a
/// reference for how to use Triton VM.
///
/// Note that all arithmetic is in the prime field with 2^64 - 2^32 + 1 elements. If the
/// provided public input or secret input contains elements larger than this, proof generation
/// will be aborted.
///
/// The program executed by Triton VM must terminate gracefully, i.e., with instruction `halt`.
/// If the program crashes, _e.g._, due to an out-of-bounds instruction pointer or a failing
/// `assert` instruction, proof generation will fail.
///
/// The default STARK parameters used by Triton VM give a (conjectured) security level of 160 bits.
pub fn prove(
    source_code: &str,
    public_input: &[u64],
    secret_input: &[u64],
) -> (StarkParameters, Claim, Proof) {
    let canonical_representation_error =
        "input must contain only elements in canonical representation, i.e., \
        elements smaller than the prime field's modulus 2^64 - 2^32 + 1.";
    assert!(
        public_input.iter().all(|&e| e <= BFieldElement::MAX),
        "Public {canonical_representation_error}"
    );
    assert!(
        secret_input.iter().all(|&e| e <= BFieldElement::MAX),
        "Secret {canonical_representation_error}"
    );

    // Convert the public and secret inputs to BFieldElements.
    let public_input_bfe = public_input
        .iter()
        .map(|&e| BFieldElement::new(e))
        .collect::<Vec<_>>();
    let secret_input_bfe = secret_input
        .iter()
        .map(|&e| BFieldElement::new(e))
        .collect::<Vec<_>>();

    // Parse the Triton assembly into a program.
    let program = Program::from_code(source_code).unwrap();

    // Generate
    // - the witness required for proof generation, i.e., the Algebraic Execution Trace (AET),
    // - the (public) output of the program, and
    // - an error, if the program crashes.
    let (aet, public_output, maybe_error) =
        vm::simulate(&program, public_input_bfe, secret_input_bfe);

    // Check for VM crashes, for example due to failing `assert` instructions or an out-of-bounds
    // instruction pointer. Crashes can occur if any of the two inputs does not conform to the
    // program, or because of a bug in the program, among other things.
    // If the VM crashes, proof generation will fail.
    if let Some(error) = maybe_error {
        panic!("Execution error: {error}");
    }

    // Convert the public output to a vector of u64.
    let public_output = public_output.iter().map(|e| e.value()).collect::<Vec<_>>();

    // Hash the program to obtain its digest.

    // Set up the claim that is to be proven. The claim contains all public information. The
    // proof is zero-knowledge with respect to everything else.
    let claim = Claim {
        input: public_input.to_vec(),
        program_digest: Tip5::hash(&program),
        output: public_output,
        padded_height: MasterBaseTable::padded_height(&aet),
    };

    // The default parameters give a (conjectured) security level of 160 bits.
    let parameters = StarkParameters::default();

    // Generate the proof.
    let proof = Stark::prove(&parameters, &claim, &aet, &mut None);

    (parameters, claim, proof)
}

/// Verify a proof generated by [`prove`].
pub fn verify(parameters: &StarkParameters, claim: &Claim, proof: &Proof) -> bool {
    Stark::verify(parameters, claim, proof, &mut None).unwrap_or(false)
}
